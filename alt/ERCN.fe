// SPDX-License-Identifier: MIT

/// @notice The event emitted when a transfer occurs.
/// @param sender The address of the sender.
/// @param receiver The address of the receiver.
/// @param id The id of the token.
/// @param amount The amount of the token.
struct Transfer {
    #indexed
    pub sender: address
    #indexed
    pub receiver: address
    #indexed
    pub id: u256
    pub amount: u256
}

/// @notice The event emitted when an operator is set.
/// @param owner The address of the owner.
/// @param spender The address of the spender.
/// @param approved The approval status.
struct OperatorSet {
    #indexed
    pub owner: address
    #indexed
    pub spender: address
    pub approved: bool
}

/// @notice The event emitted when an approval occurs.
/// @param owner The address of the owner.
/// @param spender The address of the spender.
/// @param id The id of the token.
/// @param amount The amount of the token.
struct Approval {
    #indexed
    pub owner: address
    #indexed
    pub spender: address
    #indexed
    pub id: u256
    pub amount: u256
}

contract ERCN {
    // Storage Layout
    totalSupply: Map<u256, u256>
    decimals: Map<u256, u8>
    balanceOf: Map<address, Map<u256, u256>>
    allowance: Map<address, Map<address, Map<u256, u256>>>
    isOperator: Map<address, Map<address, bool>>

    pub fn totalSupply(self, id: u256) -> u256 {
        return self.totalSupply[id]
    }

    pub fn decimals(self, id: u256) -> u8 {
        return self.decimals[id]
    }

    pub fn balanceOf(self, owner: address, id: u256) -> u256 {
        return self.balanceOf[owner][id]
    }

    pub fn allowance(self, owner: address, spender: address, id: u256) -> u256 {
        return self.allowance[owner][spender][id]
    }

    pub fn isOperator(self, owner: address, operator: address) -> bool {
        return self.isOperator[owner][operator]
    }

    pub fn transfer(
        mut self,
        mut ctx: Context,
        receiver: address,
        id: u256,
        amount: u256
    ) {
        assert self.balanceOf[ctx.msg_sender()][id] >= amount
        self.balanceOf[ctx.msg_sender()][id] -= amount
        self.balanceOf[receiver][id] += amount
        ctx.emit(Transfer(sender: ctx.msg_sender(), receiver, id, amount))
        return
    }

    pub fn transferFrom(
        mut self,
        mut ctx: Context,
        sender: address,
        receiver: address,
        id: u256,
        amount: u256
    ) {
        if ctx.msg_sender() != sender and self.isOperator[sender][ctx.msg_sender()] {
            assert self.allowance[sender][ctx.msg_sender()][id] >= amount
            self.allowance[sender][ctx.msg_sender()][id] -= amount
        }
        assert self.balanceOf[sender][id] >= amount
        self.balanceOf[sender][id] -= amount
        self.balanceOf[receiver][id] += amount
        ctx.emit(Transfer(sender, receiver, id, amount))
        return
    }

    pub fn approve(
        mut self,
        mut ctx: Context,
        spender: address,
        id: u256,
        amount: u256
    ) {
        self.allowance[ctx.msg_sender()][spender][id] = amount
        ctx.emit(Approval(owner: ctx.msg_sender(), spender, id, amount))
        return
    }

    pub fn setOperator(
        mut self,
        mut ctx: Context,
        spender: address,
        approved: bool
    ) {
        self.isOperator[ctx.msg_sender()][spender] = approved;
        ctx.emit(OperatorSet(owner: ctx.msg_sender(), spender, approved))
        return
    }

    pub fn supportsInterface(interfaceId: Array<u8, 4>) -> bool {
        let numericInterfaceId: u32 = interfaceId[0] | (interfaceId[1] << 8) | (interfaceId[2] << 16) | (interfaceId[3] << 24)
        return numericInterfaceId == 0x01ffc9a7 or numericInterfaceId == 0x8da179e8
    }
}
